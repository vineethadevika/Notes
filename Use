a) Mutexes

Program:

#include <stdio.h>

#include <stdlib.h>

#include <pthread.h>

#define NUM_THREADS 10

// Shared resource

int counter = 0;

// Mutex to protect the shared resource

pthread_mutex_t counter_mutex;

// Function to increment the shared counter

void *increment_counter(void *arg) {

pthread_mutex_lock(&counter_mutex); // Lock the mutex

counter++;

printf("Thread %ld: Counter value: %d\n", (long)arg, counter);

pthread_mutex_unlock(&counter_mutex); // Unlock the mutex

return NULL;

}

int main() {

pthread_t threads[NUM_THREADS];

pthread_mutex_init(&counter_mutex, NULL); // Initialize the mutex

// Create threads

for (long i = 0; i < NUM_THREADS; i++) {

pthread_create(&threads[i], NULL, increment_counter, (void *)i);

}

// Wait for all threads to complete

for (int i = 0; i < NUM_THREADS; i++) {

pthread_join(threads[i], NULL);

}

// Destroy the mutex

pthread_mutex_destroy(&counter_mutex);

printf("Final counter value: %d\n", counter);

return 0;

}

#include <stdio.h>

#include <stdlib.h>

#include <pthread.h>

#include<unistd.h>

#include <semaphore.h>

#define NUM_THREADS 10

#define MAX_RESOURCES 3

// Semaphore to control access to resources

sem_t resource_sem;

// Shared resource

int resource_count = 0;

// Function to simulate using a resource

void *use_resource(void *arg) {

// Wait on the semaphore (decrement)

sem_wait(&resource_sem);

resource_count++;

printf("Thread %ld: Using resource, resource count: %d\n", (long)arg, resource_count);

// Simulate some work with the resource

sleep(1);

resource_count--;

printf("Thread %ld: Finished using resource, resource count: %d\n", (long)arg, resource_count);

// Signal the semaphore (increment)

sem_post(&resource_sem);

return NULL;

}

int main() {

pthread_t threads[NUM_THREADS];

// Initialize the semaphore with a maximum resource count of MAX_RESOURCES

sem_init(&resource_sem, 0, MAX_RESOURCES);
for (long i = 0; i < NUM_THREADS; i++) {
pthread_create(&threads[i], NULL, use_resource, (void *)i);
}
// Wait for all threads to complete
for (int i = 0; i < NUM_THREADS; i++) {
pthread_join(threads[i], NULL);
}
// Destroy the semaphore
sem_destroy(&resource_sem);
return 0;
}




2nd

#include <stdio.h>

#include <stdlib.h>

#include <pthread.h>

#include <semaphore.h>

#include <unistd.h>

#define NUM_THREADS 10 // Number of threads trying to access resources

#define MAX_RESOURCES 3 // Maximum number of available resources

// Semaphore to control access to resources

sem_t resource_sem;

// Function to simulate using a resource

void *use_resource(void *arg) {

int thread_id = (int)(long)arg;

// Wait on the semaphore (decrement) to acquire a resource

sem_wait(&resource_sem);

printf("Thread %d: Acquired resource\n", thread_id);

// Simulate some work with the resource (sleep for a few seconds)

sleep(2); // Simulate time spent using the resource

// Release the resource (increment the semaphore)

printf("Thread %d: Released resource\n", thread_id);

sem_post(&resource_sem);

return NULL;

}

int main() {

pthread_t threads[NUM_THREADS];

// Initialize the semaphore with a maximum resource count

sem_init(&resource_sem, 0, MAX_RESOURCES);

// Create threads

for (long i = 0; i < NUM_THREADS; i++) {

pthread_create(&threads[i], NULL, use_resource, (void *)i);

}

for (int i = 0; i < NUM_THREADS; i++) {
pthread_join(threads[i], NULL);

}

// Destroy the semaphore

sem_destroy(&resource_sem);

return 0;

}
